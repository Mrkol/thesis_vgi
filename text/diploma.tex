\documentclass[12pt]{extarticle}



\usepackage{fontspec}
\usepackage{polyglossia}
\usepackage[a4paper, % Согласно требованиям к ВКР
  lmargin=30mm, rmargin=15mm, tmargin=20mm, bmargin=20mm]{geometry}
\usepackage{multirow}


\setdefaultlanguage{russian}
\setotherlanguage{english}



% Согласно требованиям к ВКР
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{Times New Roman}
\newfontfamily\cyrillicfont{Times New Roman}

\linespread{1.25}


\usepackage{cite}
\bibliographystyle{ugost2008}


\usepackage[dvipsnames]{xcolor}
\usepackage[hidelinks,colorlinks=true,citecolor=BurntOrange,urlcolor=Blue]{hyperref}

\renewcommand\thesection{\arabic{section}}

\usepackage{amsfonts}

\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{wrapfig}

\usepackage{graphicx}
\graphicspath{ {./images/} }



\begin{document}
\title{Имплементация виртуализации геометрии в рендеринге реального времени}

\author{Санду Р.А.\footnote{Факультет прикладной математики и информатики, кафедра корпоративных информационных систем 1С, Московский физико-технический институт, Долгопрудный 141700, Россия}}

\maketitle
\begin{abstract}
Данная работа посвящена решению задачи адаптивного рендеринга в приложениях реального времени. В качестве цели работы была выбрана имплементация иерархического атласа с виртуальным текстурированием, одного из актуальных подходов к решению этой задачи. В результате работы был выявлен и исправлен ряд недостатков и неточностей этой техники, и предложены улучшения оригинального метода. Была написана эффективная многопоточная реализация приложения конвертации моделей в формат иерархического атласа, а также приложение для рендеринга конвертированных моделей с использованием современного графического API ``Vulkan''.
\end{abstract}
\thispagestyle{empty}

\newpage
\tableofcontents
\newpage

\section{Введение}
\label{sec:intro}
С самого зарождения области интерактивной компьютерной 3D графики люди стремились повысить количество примитивов одновременно отображаемых на экране. Это один из самых естественных способов повысить общее качество изображения. Однако, не смотря на стремительное развитие графических ускорителей, наивный подход не даёт удовлетворительных результатов: в современных приложениях реального времени бюджет количества треугольников на экране остаётся достаточно ограниченным. С другой стороны современные программы для скульптурирования, а также различные технологии 3D сканирования, позволяют получить модели количество полигонов которых почти не ограничено. Бюджет приложения может быть насыщен всего лишь одним сканом в высоком качестве.

Исторически для решения этой проблемы было придумано множество техник экономии количества треугольников без потери визуального качества. Самым частым подходом является использование так называемых уровней детализации совместно с различными картами. Уровень детализации -- результат геометрического упрощения исходной модели содержащий меньше полигонов. Как правило генерируется несколько различных уровней детализации для модели с числом треугольников отличающимся на порядок, а затем при рендеринге динамически выбирается одна из них в зависимости от расстояния до наблюдателя. Различные мапы используются чтобы восстановить визуальное качество модели потерянное за счёт упрощения. Среди часто используемых карт -- normal mapping \cite{normalmapping}, различные формы displacement mapping \cite{reliefmapping}, \cite{displacementmapping}. Это семейство подходов основано на одном простом наблюдении: чем меньше видимый размер объекта на экране, тем меньше экранных пикселей он занимает, а следовательно тем менее заметны высокочастотные детали модели. Однако наивное использование уровней детализации сталкивается с множеством проблем. В случае если целевая модель много больше размера наблюдателя (например ландшафт), не редка ситуация когда наблюдатель всегда находится вблизи какой-то из частей модели, а следовательно необходимо всегда отображать всю модель в максимальном качестве. В литературе задачу решения этой проблемы называют \emph{задачей адаптивного рендеринга}. Ещё одной проблемой является потребление видеопамяти. Если просто загружать все уровни детализации всех моделей сцены в видеопамять, она достаточно быстро израсходуется. Существует множество техник решающих эту проблему. Стандартным подходом является комбинирование раннего отбрасывания моделей с графического конвейера (\cite{frustum_culling}, \cite{coorg1997real}) в сочетании с уровнями детализации и асинхронной загрузкой данных в видеопамять. Заметим, что подобные подходы не применимы к крупным объектам по аналогичным причинам: объекты рассматриваются как неделимое целое.

Виртуализация геометрии -- один из подходов к решению задачи адаптивного рендеринга. Предлагается хранить в видеопамяти только те части модели, которые необходимо отображать в данный момент, при этом только в том качестве, в котором необходимо. При этом в случае если необходимого качества в данный момент нет, вполне допустимо использовать геометрию в более низком качестве. Таким образом с точки зрения итогового изображения создаётся видимость что вся модель всегда доступна в максимальном разрешении, откуда название по аналогии с технологией виртуальной памяти используемой в операционных системах. Вариаций в реализации этой идеи достаточно много. В данной работе за основу взята статья \cite{niski2007multi}. Причиной этому послужил анонс ``Unreal Engine 5'' \cite{ue5} летом 2020 года. Было выяснено, что реализованная в нём технология микрополигонального рендеринга ``Nanite'' тоже берёт своё начало в упомянутой выше статье (согласно \cite{graphicrants_vgi}, блогу одного из разработчиков Nanite). Целью данной работы положим современную эффективную имплементацию идей этой статьи, а также исследование деталей реализации опущенных в оригинальной статье.


\subsection{Формальная постановка задачи}
Введём несколько определений используемых в данной работе.
\begin{itemize}
\item Мешем из $n$ вершин называют пару $M = (I, A)$, числа $1,...,n$ называют вершинами, $I \subset \{1, ..., n\}^3$ -- индексное множество задающее треугольники (тройки вершин), а $A: \{1, ..., n\} \rightarrow \mathbb{R}^3 \times \mathbb{R}^n$ -- атрибуты вершин, первые 3 компоненты которых считаются координатами в трёхмерном евклидовом пространстве. Меш индуцирует подмножество евклидового пространства как объединение выпуклых оболочек координат треугольников. Ради простоты отождествим треугольник как тройку индексов и выпуклую оболочку его координат, а также меш и индуцированное им множество. Остальные атрибуты меша продолжаются с вершин треугольника на все его точки посредством барицентрической интерполяции. Систему отсчёта в которой заданы координаты вершин меша называют системой отсчёта модели. В данной работе в качестве вершинных атрибутов взяты помимо координат направления нормалей в системе отсчёта модели, сдвинутой в соответствующую точку поверхности, а также координаты параметризации меша, иначе говоря UV-развёртки.
\item Дискретным многообразием (с краем) назовём меш, задающий подмножество евклидова пространства, являющееся многообразием (с краем).
\item Картой набора треугольников дискретного многообразия образующих замкнутое связное множество назовём гомеоморфизм его с $[0,1]^2$ (далее -- параметрическое пространство), однозначно задаваемый его значениями в вершинах соответствующих треугольников. Дополнительно потребуем чтобы углы параметрического пространства переходили в вершины меша, а рёбра в наборы рёбер. Таким образом область определения карты задаёт четырёхугольник на поверхности меша.
\item Набор карт, области определения которых полностью покрывают всё дискретное многообразие, назовём непрерывным атласом, если любые две области определения пересекаются либо по общему ребру этих четырёхугольников, либо по общей вершине, а также значения гомеоморфизмов разных карт согласованы на точках пересечения их областей определения. Это позволяет определить понятие соседей для карты атласа -- карт, граничащих с ней с четырёх сторон её области определения.
\item Геометрическим изображением назовём матрицу, элементами которой являются некоторые элементы $\mathbb{R}^3\times \mathbb{R}^n$. Геометрическое изображение задаёт дискретное многообразие (или его часть) посредством отождествления аттрибутов вершин и элементов матрицы и взятием множества треугольников как триангуляции прямоугольной решётки.
\item Иерархическим атласом \cite{niski2007multi} дискретного многообразия называют лес квадродеревьев, с каждой вершиной которого связана карта. При этом карты корней деревьев должны образовывать непрерывный атлас, а дети каждой вершины обязаны разбивать родительскую карту на 4 равных квадрата в параметрическом пространстве.
\item Разрезом иерархического атласа называют минимальное \emph{по включению} подмножество вершин леса такое, что любой путь из корня дерева в лист проходит по вершине этого множества. Заметим, что подмножество вершин удовлетворяет этому определению тогда и только тогда, когда объединение карт вершин этого подмножества покрывает всё многообразие без наложений.
\end{itemize}

Задача виртуализации состоит из следующих подзадач: построение непрерывного атласа по имеющемуся дискретному многообразию, построение геометрических изображений для каждой карты атласа, построение мип-уровней геометрических изображений, построение иерархического атласа, адаптация разреза, рендеринг. При этом в результате рендеринга разреза иерархического атласа изображение должно как можно меньше отличаться от изображения исходного многообразия.

\subsection{Обзор литературы}
\label{sec:related}
Рассмотрим несколько перспективных подходов к адаптивному рендерингу и сравним их с выбранным в этой работе.

\subsubsection{Subdivision surfaces with displacement maps}
Subdivision surfaces with displacement maps (далее SSDM, \cite{ssdm}) -- достаточно популярная в областях анимации и визуальных эффектов технология. Основная идея subdivision surfaces заключается в задании модели неявным образом как интерполяции набора хранимых явно узлов и рёбер, определяющих топологию поверхности (дальше -- каркас). При повторной дискретизации интерполированной поверхности появляется возможность выбрать частоту соответствующую плотности экранных пикселей на поверхности для текущего положения камеры. Сама интерполяция происходит на GPU при помощи тесселяционных шейдеров, что позволяет ограничится передачей в графическую память лишь каркаса. Название displacement mapping же говорит само за себя, каждой точке поверхности сопоставляется вектор-смещение, которые дискретизирются при помощи традиционных текстур. Использование этих идей вместе позволяет добится динамической смены уровня детализации на близких расстояниях без потери качества картинки, при этом качество ограничено исключительно разрешением используемых текстур. Более того, SSDM полностью анимируемы. Основные проблемы же этой техники начинается на средних и дальних дистанциях отрисовки, ведь наиболее разреженной интерполяцией будет служить сам каркас. При рендеринге объектов со сложной топологией необходимо задать эту топологию на уровне каркаса, что может заметно его измельчить. Также к измельчению приводит поддержка скелетных анимаций, так как привязывать к скелету можно только узлы каркаса, а не индивидуальные точки поверхности. В своей статье \cite{graphicrants_moregeometry} Брайан Карис, один разработчиков Nanite, приводит как пример модели персонажей в одном из его проектов для которых каркас пришлось сделать настолько измельчённым, что он фактически совпадал с традиционной моделью персонажа на близком уровне детализации. Ещё одним значительным недостатком является специфичность формата используемого этой техникой. Универсального алгоритма конвертации в этот формат нет, и скорее всего никогда не появится, ведь форму и плотность каркаса нужно выбирать учитывая большое количество факторов, в том числе визуальное качество результата, поэтому модели приходится делать изначально в ПО поддерживающем этот формат. Также это ограничивает возможность применения SSDM к 3D-сканам различных объектов и ландшафтов. Дальнейшее ознакомление с SSDM можно начать с \cite{ref}.

\subsubsection{Воксельный рейкастинг}
Воксельный рейкастинг \cite{cur_and_next_parallelism} -- техника, заключается в редискретизации статической геометрии по трёхмерной сетке, хранении результата в разреженном октодереве и последующем рендеринге при помощи рейкастинга из каждого экранного пикселя. Также в процессе рендеринга используется трёхмерное виртуальное текстурирование. В отличии от SSDM воксельный рейкастинг не накладывает никаких ограничений на используемые модели и форматы. Производительность не зависит от свойств модели. С помощью вокселей можно хранить любые свойства поверхности и форму геометрии в однородном виде, что упрощает весь пайплайн. Также к трёхмерным текстурам можно применять традиционные алгоритмы компрессии из обработки изображений. Ну и наконец как и SSDM эта техника позволяет выбирать частоту дискретизации основываясь на плотности пикселей, что приводит к хорошему качеству картинки на всех уровнях детализации с приемлемой производительностью. Из явных недостатков же следует упомянуть дороговизну рейкастинга с точки зрения производительности. Также заметим требовательность техники к видеопамяти и необходимость дополнительных надстроек для её экономии. Наконец отметим главный недостаток этой техники -- она абсолютно не совместима с традиционными динамическими моделями и анимациями. Как следствие появляется необходимость использовать совершенно иной подход для рендеринга динамических объектов на сцене, что приводит к сложной логике взаимодействия двух фундаментально разных систем.

\subsubsection{Маскируемые полоски}
Ещё один подход к динамическому уровню детализации представлен в \cite{RIPOLLES2009184}. Модель разбивается на набор полосок из треугольников и на этапе препроцессинга генерируется стратегия схлопывания рёбер внутри этих полосок для достижения нужного уровня детализации. Главным преимуществом этой техники является поддержка сабмешей внутри модели с разным набором вершинных атрибутов. Но в отличии от остальных упомянутых алгоритмов маскируемые полоски очень плохо справляются с низкими уровнями детализации. Алгоритм не подразумевает упрощений между несколькими полосками, из-за чего на дальних дистанциях приходится рендерить сильно больше геометрии чем необходимо. Также расширяемость размера полосок лишь в одном направлении не позволяет сильно увеличить их размер, ведь это привело бы к уменьшению качества картинки. Наконец алгоритму необходимо полностью хранить модель в памяти GPU, что ограничивает его применимость к сильно детализированным моделям.

\subsubsection{Иерархический атлас}
Сравнивая метод представленный в \cite{niski2007multi} с упомянутыми выше, использование иерархического атласа фактически позволяет избавится от всех упомянутых проблем. Путём небольшой модификации алгоритма описанного в \cite{feng2010feature} достигается поддержка скелетных анимаций. Также теоретически не должно возникнуть препятствий в использовании морф-анимаций. Используя модификацию \cite{feng2010feature} размеры карт в атласе могут быть много больше граней каркаса из SSDM, что позволяет лучше адаптировать частоту дискретизации под плотность пикселей на дальних дистанциях. Также в \cite{feng2010feature} предлагается ряд других усовершенствований позволяющих в сумме добиться десятикратного улучшения качества. Далее, конверсия моделей в формат иерархического атласа полностью автоматизирована и может быть при нужде адаптирована эвристиками под конкретное приложение. К сожалению имплементация самого алгоритма построения иерархического атласа достаточно сложна. Потребление видеопамяти алгоритмом хоть и может быть теоретически ограничено любым значением благодаря виртуализации, но требуемая для достижения фиксированного качества необходимая память растёт квадратично. Однако в воксельном рейкастинге же память растёт кубически. Наконец самое большое преимущество этой технологии -- независимость выбора частоты дискретизации геометрии, частоты дискретизации текстур, а также фактического количества частей из которого состоит вся поверхность, иначе говоря количества запусков графического пайплайна. Заменяя эвристики выбора этих параметров можно адаптировать алгоритм под конкретные данные. Как один из недостатков можно упомянуть что выбор частоты дискретизации хоть и достаточно мелкогранулярен благодаря квадродеревьям, но всё равно проигрывает воксельному рейкастингу где частоту можно независимо выбирать для каждого экранного пикселя. Ещё одним недостатком всех упомянутых схем является применимость их лишь к определённому роду геометрии. Например использование их с моделью кованого металлического забора с особо сложным рисунком вряд ли даст прирост в производительности или качестве по сравнению с традиционным рендерингом.

Наконец стоит отметить, что при приближении частоты дискретизации модели треугольниками к частоте дискретизации экрана пикселями начинают появляться проблемы алиасинга и "промахивания" треугольников мимо точки семплирования пикселей. В одном из интервью Карис упомянул что для решения этой проблемы при использовании иерархического атласа для создания Nanite (\cite{nanite}) их команде пришлось написать свой программный растеризатор.

\begin{table}[ht]
\small
\centering
\begin{tabular}{ p{24mm} | p{26mm} | p{18mm} | p{20mm} | p{16mm} }
                       & Гранулярность по скринспейсу & Скелетные анимации & Упрощение на высоких дистанциях & Связность \\
\hline
Статические уровни детализации & Нет                          & Да                 & Не ограничено            & Явная     \\
\hline
Иерархический атлас    & Сильная                      & Да                 & Сильное                  & Неявная   \\
\hline
SSDM                   & Средняя                      & Да                 & Слабое                   & Явная     \\
\hline
Воксельный рейкастинг  & Сильная                      & Нет                & Не ограничено            & Неявная   \\
\hline
Маскируемые ленты      & Нет                          & Да                 & Слабое                   & Неявная   \\
\end{tabular}
\caption{Сравнение возможностей рассмотренных подходов}
\end{table}

\begin{table}[ht]
\small
\centering
\begin{tabular}{ p{24mm} | p{24mm} | p{24mm} | p{24mm} | p{24mm} }
                      & Гранулярность по дистанции & Динамическая детализация
                      & Неоднородные атрибуты & Предобработка \\
\hline
Иерархический атлас   & Сильная & Текстуры, геометрия            & Нет & Автоматическая \\
\hline
SSDM                  & Сильная & Геометрия                      & Нет & Ручная \\
\hline
Воксельный рейкастинг & Средняя & Геометрия, топология, текстуры & Нет & Автоматическая \\
\hline
Маскируемые ленты     & Средняя & Геометрия                      & Вершинные & Автоматическая \\
\end{tabular}
\caption{Сравнение возможностей рассмотренных подходов (продолжение)}
\end{table}


\section{Разработанное решение}
\begin{figure}
  \includegraphics[scale=0.145]{clustering.png}
  \includegraphics[scale=0.145]{straightening.png}
  \includegraphics[scale=0.145]{quadrangulation.png}
  \caption{Визуализация этапа предобработки (слева направо: кластеризация, распрямление границ, квадрангуляция)}
\end{figure}

В базовом виде алгоритм из статьи \cite{niski2007multi} делится на два этапа: предобработка и рендеринг. Алгоритм предобработки принимает на вход дискретное многообразие (возможно с краем), хранимое в формате ``треугольного супа'' -- неиндексированного набора треугольников, где каждый треугольник задан аттрибутами его вершин. Этот формат был выбран в целях упрощения имплементации предобработки во внешней памяти.

\subsection{Предобработка}
Цель этапа предобработки -- построить непрерывный атлас меша, а затем ресемплировать атрибуты в каждой карте атласа по равномерной сетке в параметрическом пространстве, тем самым получив семейство геометрических изображений. Предлагаемый алгоритм состоит из следующих этапов:
\begin{enumerate}
\item Раскладывание треугольников по бакетам
\item Кластеризация треугольников в рамках бакетов
\item Глобальная кластеризация
\item Распрямление границ кластеров
\item Квадрангуляция
\item Репараметризация
\item Ресемплинг
\end{enumerate}

\subsubsection{Раскладывание треугольников по бакетам}
Этот и последующий этапы фактически являются оптимизациями основного алгоритма, необходимыми для работы с большими мешами. Пространство модели разбивается по прямоугольной равномерной трёхмерной сетке на ``бакеты'', треугольники каждого бакета проходят следующий этап независимо, что позволяет запускать его параллельно на многоядерных процессорах.

\subsubsection{Кластеризация}
Цель кластеризации -- разбить все треугольники на непересекающиеся связные множества (называемые кластерами), оптимизируя некоторые эвристики и сохраняя некоторые инварианты. В данной работе используются эвристики планарности, компактности и изменения иррегулярности. Новые кластеры строятся последовательным объединением имеющихся кластеров минимизируя целевые эвристики.

Пусть $M$ -- кластер, состоящий из вершин $\{v_1, ..., v_k\}$. Для удобства будем считать, что вершины заданы в однородных координатах. Плоскость будем задавать однородным вектором $n$, задающим множество точек плоскости как решения $n^\top v = 0$. Рассмотрим среднеквадратичное отклонение вершин кластера от произвольной поверхности:
\[
  E_M(n) = \frac{1}{k}\sum_{i=1}^k (n^\top v_i)^2.
\]
Обозначим точку минимума этой функции, то есть прямую приближающую кластер методом наименьших квадратов, за $n_0$. Тогда эвристикой планарности кластера назовём
\[
  E_{fit}(M) = E_M(n_0).
\]
Конечно же вычисление этой эвристики заново на каждой итерации алгоритма приведёт к квадратичной асимптотике, что неудовлетворительно. Для эффективного вычисления в \cite{garland2001} предлагается использовать поверхности второго порядка. Раскрывая скобки в определении $E_M$,
\[
  E_M(n) = \frac{1}{k}\sum_{i=1}^k n^\top(v_iv_i^\top) n
    = \frac{1}{k}n^\top\left(\sum_{i=1}^k v_iv_i^\top\right) n
    = \frac{1}{k}n^\top Q_M n,
\]
где $Q_M = \sum_{i=1}^k v_iv_i^\top$. Так как $Q_{M\cup N} = Q_M + Q_N$, для вычисления $E_M$ достаточно хранить для каждого кластера его форму $Q_M$, а при объединении кластеров складовать их.

Саму МНК плоскость же можно найти используя выборочную ковариационную матрицу
\[
  Z = \frac{1}{1-k}\sum_{i=1}^k (v_i - \bar v)(v_i - \bar v)^\top.
\]
Первые три координаты $n_0$ будут равны первым трём координатам собственного вектора $Z$ соответствующего наименьшему собственному значению, а последняя координата может быть вычислена из равенства $n_0^\top \bar v = 0$. К счастью, матрица $Z$ также может быть вычислена через форму $Q_M$:
\[
  Z = \sum_{i=1}^k v_iv_i^\top - k(\bar v \bar v^\top) = Q_M - \frac{Q_{M1:3,4}Q_{M1:3,4}^\top}{Q_{M4,4}},
\]
где константа пропорциональности опущена так как не влияет на направления собственных векторов и положения в вариационном ряду собственных значений. Это наблюдение и позволяет вычислять ошибку планарности на каждой итерации алгоритма за $O(1)$.

Пусть площадь и периметр кластера $M$ равны $A$ и $P$ соответственно. Тогда иррегулярностью кластера называют величину
\[
  \gamma(M) = \frac{P^2}{4\pi A}.
\]
Иррегулярность измеряет степень схожести кластера с диском. Эвристикой изменения иррегулярности для объединения кластеров $N_1, N_2$ в кластер $M$ называют
\[
  E_{shape} = \frac{\gamma(M) - \max(\gamma(N_1), \gamma(N_2))}{\gamma(M)}.
\]
Эвристикой компактности же назовём
\[
  E_{comp}(M) = P^2.
\]

Эвристики изменения иррегулярности и планарности взяты из работы \cite{garland2001}, но попытка использовать подход описанные в этой работе как есть не увенчалась успехом: эвристика ориентации не вносила значительного вклада в результат на тестовых моделях, а эвристики изменения иррегулярности оказалось недостаточно чтобы предать кластерам округлую форму (отношение квадрата периметра к площади кластера могло оставаться близким к $4\pi$ даже когда кластер имеет крайне вытянутую форму за счёт ``ребристости'' поверхности, так как ребристость увеличивает площадь не меняя периметра). Было принято решение отказаться от эвристики ориентации, а эвристику изменения иррегулярности заменить на некоторую другую метрику. Из вариантов были рассмотрены просто иррегулярность, квадрат периметра и сумма квадрата периметра и изменения иррегулярности. Последний вариант дал наиболее благоприятный результат: сам по себе квадрат периметра приводил к слишком ломаным границам между кластерами, а учёт изменения иррегулярности позволил сгладить этот эффект. Однако квадрат периметра не совпадает по размерности с остальными эвристиками, что потребовало подбора коэффициента вклада этой эвристики под конкретную модель. На использованных тестовых моделях (ландшафты \cite{quixel_megascans}) наилучший результат дал коэффициент $10^{-4}$ для компактности, $1.7$ для планарности и $1$ для изменения иррегулярности.

В процессе кластеризации на кластеры накладывается следующий топологический инвариант: пересечение любых двух кластеров гомеоморфно либо точке, либо отрезку, и при этом граница любого кластера гомеоморфна окружности. Этот инвариант позволит на этапе квадрангуляции получить разбиение, удовлетворяющее определению непрерывного атласа.

Используется жадный алгоритм кластеризации, строящий кластеры снизу-вверх. Поддерживается очередь с приоритетами из пар кластеров -- претендентов на слияние. Приоритетом является сумма эвристик посчитанных для объединения кластеров. В ходе итерации алгоритм берёт потенциальный мердж с минимальной ошибкой из очереди, проверяет не нарушит ли он топологические инварианты, объединяет кластеры с использованием структуры данных ``система непересекающихся множеств'', затем обновляет приоритеты потенциальных мерджей кластера этой итерации и его соседей. Алгоритм прекращает свою работу при достижении целевого количества кластеров или превышении дозволенной ошибки.

\subsubsection{Глобальная и локальная кластеризация}
\begin{figure}[ht]
\minipage{0.32\textwidth}
  \centering
  \begin{tikzpicture}[scale=1.2]
    \coordinate (A) at (0,1.5);
    \coordinate (B) at (0,1);
    \coordinate (C) at (0,-1);
    \coordinate (D) at (0,-1.5);

    \filldraw[blue!10] (-2, 2) -- (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2) -- (-2,-2) -- cycle;
    \filldraw[red!10] (2, 2) -- (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2) -- (2,-2) -- cycle;

    \draw (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2);
    \draw (2,2) -- (A) -- (B) -- (1,0) -- (C) -- (D) -- (2,-2);

    \node at (-1.5,0) {А};
    \node at (1.5,0) {Б};
  \end{tikzpicture}
  \caption{Нарушение инварианта при наивном объединении бакетов}
  \label{fig:naive_inv_invalid}
\endminipage\hfill
%
\minipage{0.32\textwidth}
  \centering
  \begin{tikzpicture}[scale=1.2]
    \coordinate (E) at (0.5,1.25);
    \coordinate (F) at (0.5,-1.25);
    \coordinate (O) at (1.25,-0.75);

    \filldraw[blue!10] (-2, 2) -- (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2) -- (-2,-2) -- cycle;
    \filldraw[red!10] (2,2) -- (1, 2) -- (E) -- (0.75,0) -- (1.25,-0.25) -- (1.75,-0.75) -- (1.25,-1.25) -- (F) -- (1,-2) -- (2,-2) -- cycle;


    \draw (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2);
    \draw (1, 2) -- (E) -- (0.75,0) -- (1.25,-0.25) -- (1.75,-0.75) -- (1.25,-1.25) -- (F) -- (1,-2);
    \draw (0.75,0) -- (-0.5,0) -- (F) -- cycle;

    \draw  (0.75,0) -- (O) -- (1.25,-0.25) -- (O) -- (1.75,-0.75) -- (O) -- (1.25,-1.25) -- (O) -- (F);

    \node at (0.25,-0.4) {А};
    \node at (1.5,0) {Б};
  \end{tikzpicture}
  \caption{Нарушение инварианта при объединении бакетов с разграничителем}
  \label{fig:smart_inv_invalid}
\endminipage\hfill
%
\minipage{0.32\textwidth}
  \centering
  \begin{tikzpicture}[scale=1.2]
    \filldraw[blue!10] (-2, 2) -- (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2) -- (-2,-2) -- cycle;
    \filldraw[red!10] (2,2) -- (1, 2) -- (E) -- (0.75,0) -- (1.25,-0.25) -- (1.75,-0.75) -- (1.25,-1.25) -- (F) -- (1,-2) -- (2,-2) -- cycle;


    \draw (-0.5, 2) -- (A) -- (B) -- (-0.5,0) -- (C) -- (D) -- (-0.5,-2);
    \draw (1, 2) -- (E) -- (0.75,0) -- (1.25,-0.25) -- (1.75,-0.75) -- (1.25,-1.25) -- (F) -- (1,-2);
    \draw (0.75,0) -- (-0.5,0) -- (F) -- cycle;

    \draw  (0.75,0) -- (O) -- (1.25,-0.25) -- (O) -- (1.75,-0.75) -- (O) -- (1.25,-1.25) -- (O) -- (F);

    \draw[red] (-0.5,0) -- (0.625,-0.625) -- (O);
    \filldraw[red] (0.625,-0.625) circle (2pt);
  \end{tikzpicture}
  \caption{Устранение нарушений при объединении бакетов с разграничителями}
  \label{fig:inv_valid}
\endminipage\hfill
\end{figure}
Приведённый алгоритм кластеризации используется и на 3 и на 4 этапах, но в ходе 3 этапа каждый треугольник в бакете считается отдельным кластером, а в ходе 4 этапа изначальным набором кластеров берётся объединение результатов работы предыдущего этапа. Очевидно, на входе 3 этапа топологический инвариант выполнен. Каждая итерация алгоритма сохраняет инвариант, поэтому в рамках каждого бакета он тоже выполнен. Однако несложно построить пример ситуации когда инвариант нарушается при объединении бакетов. На рисунке  \ref{fig:naive_inv_invalid} синим и красным цветом обозначены кластеры двух разных бакетов соответственно. Кластеры А и Б пересекаются по несвязному множеству, тем самым нарушая инвариант, хотя в рамках каждого бакета инвариант выполнен. В работе \cite{niski2007multi} никак не уточняется этот момент, однако практика показывает что если бакеты достаточно велики отностельно детализации меша, то эта проблема возникает достаточно редко. С целью устранения этой проблемы было решено не включать в бакет треугольники пересекающие его границы, а добавлять их как отдельные кластеры при переходе к 4 этапу. Этот подход позволяет частично избежать ситуации с рисунка \ref{fig:naive_inv_invalid}, но инвариант всё ещё может быть нарушен как на рисунке \ref{fig:smart_inv_invalid}: кластер границы А и кластер правого бакета Б пересеклись по несвязному множеству, двум точкам. Если в дополнение к этому подходу разделять треугольники нарушившие инвариант на 2 части, либо использовать граничные треугольники в проверке инварианта в каждом бакете, то проблема окончательно пропадает. В данной работе был выбран следующий подход. Рассмотрим множество треугольников пересёкших границы бакетов (То есть таких, что не все вершины попали в один бакет. Это условие необходимо и достаточно, так как и треугольник и бакет -- выпуклые множества). Ясно, что топологически эта фигура является двумерной поверхность с $n$ дырками. Обозначим за $A_i$ множества вершин, образующие границы дырок. Рассмотрим рёбра такие, что их вершины принадлежат множеству $A_i$, но на ребро опираются 2 треугольника (т.е. ребро не лежит на границе дырки). Разделим все такие рёбра и смежные с ними треугольники пополам (рисунок \ref{fig:inv_valid}). Легко понять, что после этой операции любой треугольник пересекается со всей поверхностью кластера либо ровно по одной вершине, либо по ровно по одному ребру, чего и достаточно для соблюдения инварианта при объединении всех бакетов и граничного множества.

\begin{figure}[ht]
\centering
\begin{tikzpicture}
  \filldraw[blue!10] (-4,0) -- (-3,1) -- (-2,0.75) -- (-1,1.25) -- (1,0.5) -- (3,2) --
    (4,0) -- (3,-1) -- (1,-0.5) -- (-1,-1.5) -- (-2.5,-1) -- cycle;
  \draw[very thick] (-4,0) -- (-3,1) -- (-2,0.75) -- (-1,1.25) -- (1,0.5) -- (3,2) --
    (4,0) -- (3,-1) -- (1,-0.5) -- (-1,-1.5) -- (-2.5,-1) -- cycle;
  \draw (-2,0.75) -- (-1,-1.5);
  \draw (1,0.5) -- (1,-0.5);

  \draw[red, thick] (-2,0.75) -- (-1,1.25) -- (1,0.5);
  \draw[red, thick] (1,-0.5) -- (-1,-1.5);
  \node at (-0.5,0) {А};
\end{tikzpicture}
\caption{Атлас с картой А пересекающей границу по несвязному множеству (отмечено красным)}
\label{fig:weird_edge}
\end{figure}
Ещё одним тонким моментом в процессе кластеризации является работаа с границей многообразия. Авторы \cite{purnomo2004} не уточняют в своих определениях считается ли атлас, одна из карт которого имеет область определения пересекающуюся с границей меша по двум несвязным отрезкам, корректным (рисунок \ref{fig:weird_edge}). В данной работе считается, что вся граница многообразия является границей одной карты, что запрещает ситуации как на рисунке.

\subsubsection{Распрямление границ}
При использовании некоторых эвристик границы кластеров получаются достаточно ломанными, что приводит к артефактам на их границах при рендеринге. С целью борьбы с этой проблемой на этом этапе пары граничащих кластеров загружаются в память и граница между ними заменяется на кратчайший путь из конца в начало найденный алгоритмом Дейкстры \cite{dijkstra}. В этот этап тоже достаточно легко вносится параллелизм. Так как операция распрямления границы мутирует пару файлов-кластеров, необходимо убедится что никакие два исполнителя не будут параллельно распрямлять границы принадлежащие одному кластеру.

\subsubsection{Квадрангуляция}
\begin{figure}[ht]
\minipage{0.475\textwidth}
  \centering
  \begin{tikzpicture}[scale=1.2]
    \filldraw[blue!10] (-3,1) -- (-3,0)
    -- (-1.5,0) -- (-1,-1) -- (-1,-2) -- (-0.5,-2.5)
    -- (0,-4)
    -- (1.5,-2) -- (1,-1)
    -- (2,0) -- (3,-0.5) -- (3,1) -- cycle;

    \draw (-3,0)
    -- (-1.5,0) -- (-1,-1) -- (-1,-2) -- (-0.5,-2.5)
    -- (0,-4)
    -- (1.5,-2) -- (1,-1)
    -- (2,0) -- (3,-0.5);
    \draw (-1.5,0) -- (0,0.5) -- (1,-1);

    \draw[red] (-1.5,0) -- (1,-1);
    \draw[red] (1,-1) -- (-1,-1);
    \draw[red] (-1,-1) -- (1.5,-2);
    \draw[red] (1.5,-2) -- (-1,-2);
    \draw[red] (1.5,-2) -- (-0.5,-2.5);

    \draw[dashed,red] (0,0.5) -- (-0.25,-0.5) -- (-1,-1);
    \draw[dashed,red] (-0.25,-0.5) -- (0,-1) -- (1.5,-2);
    \draw[dashed,red] (0,-1) -- (0.25,-1.5) -- (-1,-2);
    \draw[dashed,red] (0.25,-1.5) -- (0.25,-2) -- (-0.5,-2.5);
    \draw[dashed,red] (0.25,-2) -- (0.5,-2.25) -- (0,-4);

    \filldraw[red] (-0.25,-0.5) circle (1pt);
    \filldraw[red] (0,-1) circle (1pt);
    \filldraw[red] (0.25,-1.5) circle (1pt);
    \filldraw[red] (0.25,-2) circle (1pt);
    \filldraw[red] (0.5,-2.25) circle (1pt);
  \end{tikzpicture}
  \caption{Разделение рёбер для построения путей при квадранугялции. Сплошные красные -- рёбра, подлежащие разделению, красные точки -- новые вершины, красный пунктир -- дополнительные рёбра}
  \label{fig:quadr_split}
\endminipage\hfill
%
\minipage{0.475\textwidth}
  \centering
  \begin{tikzpicture}[scale=1.2]
    \draw (-2,2) -- (0,3) -- (2.5,0.5) -- (0.5,-1.5) -- (-1.5,-1) -- cycle;
    \draw[red] (0,1) -- (-1,2.5);
    \draw[red] (0,1) -- (1.25,1.75);
    \draw[red] (0,1) -- (1.5,-0.5);
    \draw[red] (0,1) -- (-0.5,-1.25);
    \draw[red] (0,1) -- (-1.75,0.5);
  \end{tikzpicture}
  \caption{Квадрангуляция. Чёрные рёбра -- схематичное представление исходного кластера как многоугольника, красным -- пути разрезания кластера на четырёхугольники}
  \label{fig:quadr}
\endminipage
\end{figure}
Легко увидеть, что в результате кластеризации каждый кластер геометрически является $n$-угольником. Вершинами назовём точки, в которых пересекаются более чем $2$ кластера, считая воображаемую область за границей меша отдельным кластером. Рёбрами назовём множества из тех точек, в которых пересекаются ровно 2 кластера. В ходе этого этапа в каждом кластере выделяется вершина называемая центром, а затем проводятся кривые из центра к серединам рёбер. Кривые строятся алгоритмом $A^*$ \cite{astar} так, чтобы кривые шли как можно дальше друг от друга, от границы всего кластера, и не пересекались. Для достижения этого эффекта веса рёбер взвешиваются единицей делённой на расстоянием до нежелаемого множества. Порядок выбора рёбер для проведения кривых следующий: первая кривая произвольная, а затем в самом большом по количеству рёбер регионе из получившегося разбиения выбирается центральное ребро. Этот подход позволяет итоговым четырёхугольникам быть примерно одинакового масштаба и пропорций. В случае если это построение не возможно, предлагается разделять мешающие треугольники. Авторы не уточняют используемый алгоритм поиска мешающих треугольников, а также способ разделения, поэтому в данной работе было решено использовать следующий подход. На каждой итерации проведения кривой в регионе, ищутся все рёбра такие, что само ребро не лежит на границе, но при этом обе его вершины лежат на границе. Далее эти рёбра делятся пополам, как и опирающиеся на них треугольники. На рисунке \ref{fig:quadr_split} красным цветом обозначены описанные рёбра, а пунктиром обозначено дополнительное построение получающееся в результате последовательного разделения красных рёбер. После этого разделения пути гарантированно будут существовать.

Пусть дан граф триангуляции диска, вершины $O$, $M$ лежат на границе, и любой путь между ними проходит ещё хотя бы один раз по границе. Покажем, что тогда найдётся ребро не лежащее на границе, но обе вершины которого лежат на ней (назовём такие рёбра плохими). Тогда по контрапозиции получим корректность алгоритма.
%
Доказывать будем по индукции. Базой будут такие графы, в которых нет смежных внутренних вершин. Если же в графе есть смежные внутренние вершины, стянем ребро между ними. Каждому пути в старом графе можно сопоставить путь в новом графе, при этом не потеряв посещения границы на них. Значит по предположению индукции в графе есть плохое ребро. Но операция стягивания ребра не могла добавить новых плохих рёбер. Значит плохое ребро было и в старом графе.
%
Пусть в графе нет смежных внутренних вершин. Если в графе любая граничная вершина имеет степень не больше трёх, очевидно граф выглядит как $n$-угольник и в нём есть пути из любой вершины границы в любую другую не проходящие по границе, что противоречит условию. Значит найдётся вершина на границе со степенью хотя бы 4. Рассмотрим её соседей в порядке обхода. Заметим, что 2 подряд идущих соседа не могут быть внутренними вершинами. Значит кроме первой и последней вершины в порядке обхода мы нейдём ещё одну вершину лежащую на границе. Эта вершина и изначальная и будут образовывать целевой плохое ребро.
%
Таким образом в любом графе с описанными свойствами найдётся плохое ребро, что и требовалось доказать.

Из рисунка \ref{fig:quadr} видно, что в ходе этой операции многогранник будет разбит на четырёхугольники. Более того, легко увидеть, что полученное разделение будет удовлетворять определению непрерывного атласа. Пары четырёхугольников полученных из одного кластера пересекаются по построению либо по общей вершине, либо по общему ребру. Сами кластеры из поддерживаемого инварианта пересекаются аналогичным образом. А так как новые вершины ставятся на серединах рёбер кластеров одинаковым образом, из чего четырёхугольники разных кластеров тоже пересекаются либо по общему ребру, либо по общей вершине.

Стратегия выбора центра предлагаемая \cite{purnomo2004} достаточно произвольна. Выбирается одно из рёбер многогранника, из его центра проводятся кривые в центры других рёбер, а затем центры проведённых кривых в порядке обхода принимаются за новый многогранник, у которого на 1 ребро меньше, после чего процедура запускается рекурсивно пока не останется вырожденного многогранника из меньше чем трёх точек, центр которого берётся за центр всего кластера.

Отметим, что в случае если в кластере все вершины лежат на границе, алгоритм не будет работать корректно, так как не удастся найти центр. Эту проблему не сложно решить добавив новую произвольную вершину, но в данной работе не возникло в этом нужды так как столь малые кластеры не удовлетворительны для дальнейшей работы метода, и алгоритм кластеризации не оставляет таких кластеров при должном критерии остановки.

\subsubsection{Репараметризация}
После этапа квадрангуляции меш разделён на области определения карт для итогового атласа. Далее необходимо построить согласованные гомеоморфизмы для каждого четырёхугольника на единичный квадрат, то есть построить параметризацию. Задача построения параметризации широко известна в области компьютерной графики, и к её решению было придумано много подходов. Большая часть из них берут за исходную параметризацию вложение Татта \cite{tutte1963}, а затем оптимизируют некоторый целевой функционал, не нарушающий инъективности исходной параметризации. В данном алгоритме важно, при ресемплинге частота дискретизации была пропорциональна кривизне исходной поверхности в каждой точке, поэтому был выбран подход из статьи \cite{sander2001}. Для корректности получившегося атласа в процессе построения параметризации вершины, соответствующие углам четырёхугольника, были закреплены на углах единичного квадрата, а вершины лежащие на границе были распределены по границам квадрата пропорционально длине рёбер, и также зафиксированы.

\subsubsection{Ресемплинг}
Цель ресемплинга -- построить геометрические изображения содержащие информацию об атрибутах меша в его точках, соответствующих точкам на равномерной прямоугольной сетке в пространстве параметризации. Заметим, что при таком построении для двух соседних карт их пересечение будет семплировано в оба геометрических изображения соответствующих этим картам. Таким образом если спроецировать области геометрических текстур на исходную модель, соседние изображения будут иметь пересечение в $0.5$ пикселя. Для удобства построения квадродеревьев в следующем разделе в качестве частоты ширины и высоты геометрических изображений берутся исключительно числа вида $2^n + 1$.

Также для адаптивного рендеринга необходимо сгенерировать мип-уровни для итоговых геометрических текстур. Авторы статьи \cite{purnomo2004} предлагают использовать фильтрацию с достаточно сложной обработкой граничных случаев, однако так как каждый следующий мип-уровень в 4 раза меньше предыдущего, делать ресемплинг для каждого уровня заново занимает всего в $\approx1.3$ раза дольше ресемплинга самого высокочастотного мип-уровня, поэтому в данной работе был выбран именно этот подход.

Небольшой проблемой упомянутой в \cite{niski2007multi} стали правила растеризации. При семплировании по описанной выше схеме граничные семплы приходятся ровно на границу патча. В такой ситуации растеризатор не считает что семплы нижней и правой грани попали внутрь патча, поэтому не генерирует фрагментов для них. Эта проблема легко устраняется рендерингом этих граней отдельно от основных треугольников. Однако метод предложенный в \cite{niski2007multi} преобразует эти грани не так, как основную часть модели, что может привести к неточностям и артефактам. При использовании такого же преобразования возникает проблема с правым нижнем пикселем: согласно правилам растеризации он вновь не будет закрашен. Но так как вся информация об атрибутах в этой точке уже известна из изначальной модели, в данной работе мы заполняем это недостающее значение уже после основного ресемплинга.

\subsection{Рендеринг}
\begin{figure}[ht]
\minipage{0.45\textwidth}
  \centering
  \begin{tikzpicture}[scale=0.75]
    \draw (0,0) grid (9,9);
    \draw[step=4,thick,xshift=0.5cm,yshift=0.5cm] [red] (0,0) grid (8,8);
  \end{tikzpicture}
  \caption{Расположение вершин квадродерева в параметрическом пространстве.}
  \label{fig:quadtree}
\endminipage\hfill
%
\minipage{0.45\textwidth}
  \centering
  \begin{tikzpicture}[scale=0.7]
    \draw (0,0) grid (10,10);
    \filldraw [red, opacity=0.5, xshift=0.5cm,yshift=0.5cm]
      (0,0) rectangle (4,4)
      (0,5) rectangle (4,9)
      (5,0) rectangle (9,4)
      (5,5) rectangle (9,9);
  \end{tikzpicture}
  \caption{Области семплирования страниц в кэше }
  \label{fig:cache}
\endminipage
\end{figure}
Как было упомянуто выше, для мелкогранулярного выбора уровня детализации по модели данный алгоритм использует квадродеревья в рамках каждой карты. На каждом уровне дерева пространство параметризации делится на 4 равных квадрата. Из этого следует что граница разделения проходит по середине центрального пикселя геометрического изображения, соответственно новым вершинам дерева соответствуют регионы геометрического изображения пересекающиеся по центральным пикселям и имеют размер $2^{n-1} + 1$ (рисунок \ref{fig:quadtree}).

Для адаптации иерархии был выбран простейший алгоритм из \cite{niski2007multi} постепенно измельчающий разрез квадродерева в попытке сэкономить полигоны адаптируя части квадродерева по отдельности. Адаптация мип-уровня вершин квадродерева происходит посредством вычисления ограничивающей призмы, проецированием её в пространство камеры и поиском ограничивающего её прямоугольника. Логарифм корня площади этого прямоугольника в пикселях с учётом некоторой константы пропорциональности берётся за целевую плотность треугольников для данной вершины.


\subsubsection{Виртуализация}
Для виртуализации геометрических изображений был выбран простой алгоритм LRU-кэширования. Размер наименьшего мип-уровня $K$ берётся за размер страницы кэша, каждое геометрическое изображение разрезается на страницы с наложением в один пиксель (аналогично соответствию регионов пространства параметризации вершинам квадродерева), по мере нужды страницы соответствующих изображений загружаются в кэш хранимый на видеокарте (без наложения). Наличие отступа в полпикселя у каждой страницы с каждой стороны позволяет использовать билинейную фильтрацию для кэша без возникновения артефактов на границах. На рисунке \ref{fig:cache} красным обозначены сэмплируемые области страниц, интерполяция пикселей из разных страниц в остальной области не влияет на отображаемый результат.

Для вычисления позиции страницы определённого изображения $I$ на определённом мип-уровне $M$ в кэше используются таблицы индирекции. $I,M$-таблица имеет размер $2^{M - K}$ по высоте и ширине и в ячейках содержит либо номер ячейки в кэше содержащей соответствующую страницу, либо служебное значение $-1$, означающее что страница отсутствует в кэше.

Для стабилизации частоты кадров количество страничек загружаемых за один кадр в кэш ограничено. Из-за этого может возникать нужда в момент рендеринга получить данные из страницы не находящейся в данный момент в кэше. В таком случае вычисляется в какой странице мип-уровня на 1 меньше целевого находится текущая точка поверхности и повторяем процедуру лукапа страницы. Процесс повторяется пока не будет найдена доступная в кэше страница. Чтобы таковая всегда была, изображения наименьшего мип-уровня никогда не извлекаются из кэша. Таким образом не зависимо от состояния кэша всегда есть возможность отобразить модель в каком-то качестве, возможно меньшем чем желаемое.

Важным моментом является факт дублирования граничной информации страниц -- при вычислении элемента таблицы лукапа для точки параметрического пространства лежащей на границе между несколькими страницами можно выбрать любую из них. Однако неосторожная обработка этого момента может привести к разрывам. В данной работе всегда выбирается страница целиком лежащая в регионе текущей вершины атласа, а разрывы устраняются в рамках описанного ниже алгоритма.

\subsubsection{Устранение разрывов}
\begin{figure}[ht]
\minipage{0.45\textwidth}
  \centering
  \begin{tikzpicture}
    \draw[step=2] (0,0) grid (4,4);
    \draw[step=1] (4,0) grid (8,4);
    \filldraw[red] (4,1) circle (2pt);
    \filldraw[red] (4,3) circle (2pt);
    \node at (3.75,1) {А};
    \node at (3.75,3) {Б};
  \end{tikzpicture}
  \caption{Потенциальные разрывы}
  \label{fig:tearing}
\endminipage\hfill
%
\minipage{0.45\textwidth}
  \centering
  \begin{tikzpicture}
    \draw[step=2] (0,0) grid (4,4);
    \draw[step=1] (5,0) grid (8,4);
    \draw (4,0) -- (5,0);
    \draw (4,0) -- (5,1);
    \draw (4,0) -- (5,2);
    \draw (4,2) -- (5,2);
    \draw (4,4) -- (5,4);
    \draw (4,4) -- (5,3);
    \draw (4,4) -- (5,2);
  \end{tikzpicture}
  \caption{Устранение разрывов}
  \label{fig:stitching}
\endminipage
\end{figure}
При наивном рендеринге граничащих вершин квадродеревьев с разными мип-уровнями геометрических изображений будут образовываться разрывы из-за разной частоты дискретизации границы. На рисунке \ref{fig:tearing} вершины А и Б со стороны правой вершины могут не совпасть по координатам с серединой соответствующих рёбер левой вершины. Для устранения этой проблемы необходимо схлопывать рёбра со стороны вершины с б\'ольшим мип-уровнем согласно рисунку \ref{fig:stitching}. Однако может образовываться ситуация в которой вершина с высоким мип-уровнем граничит по одному ребру с несколькими вершинами различных более низких мип-уровней. В этой ситуации необходимо взять минимум из всех мип-уровней вершин опирающихся на это ребро и выбрать мип-уровень границы именно таким.

В данной работе используется следующий алгоритм поиска мип-уровней границ. Рассматриваются только вершины из активного среза. При изменении мип-уровня вершины перебрать все её рёбра, для каждого ребра найти всех опирающихся на него соседей и выбрать наибольшую по физическому размеру вершину. Для этой вершины находим всех соседей со стороны граничащей с изначальной вершиной, находим минимум из их мип-уровней и устанавливаем всем им мип-уровень границы на найденный минимум.

Для поиска соседних вершин входящих в срез, как отмечают в \cite{niski2007multi}, необходимо хранить в корнях деревьев 4 ссылки на соседние квадродеревья (их количество таково из свойств областей определений карт), а также ссылки на родителя в каждой вершине. Однако этой информации не достаточно. Как и при работе с обычными многообразиями, для переноса информации между различными картами необходимо иметь \emph{отображение склейки}, позволяющее отобразить параметрические координаты одной карты в параметрические координаты другой для точек лежащих в обоих картах. Для рассматриваемых нами атласов эти отображения всегда являются композицией переноса на целое число вдоль одной из осей и поворота на угол кратный $\frac{\pi}{2}$. Матрицы, задающие эти отображения, легко предподсчитываются сопоставлением координат вершин соответствующих углам геометрических изображений.

В данной работе дополнительно предподсчитываются для каждой вершины и каждой её стороны вершина, с которой достаточно начинать поиск соседей. В случае если с целевой стороны находится край текущей карты, этой вершиной является корень соседнего дерева. В ином случае такой вершиной служит первый из родителей текущей в порядке подъёма такой, что все вершины опирающиеся на грань текущей являются его потомками.

Наконец отметим, что при поиске мип-уровней границ необходимо учитывать в каком разрешении доступны страницы геометрического изображения на GPU на данном кадре. Для этого достаточно включать в поиск минимального мип-уровня для грани мип-уровни страниц, опирающихся на эту грань.

\subsubsection{Графический конвейер}
Для рендеринга иерархического атласа хорошо подходят тесселляционные шейдеры. Каждая модель рендерится при помощи одного вызова отрисовки с использованием инстансинга. Инстансы соответствуют выбранным вершинам квадродеревьев атласа, а количество вершин в каждом инстансе равно 4. Для каждого из них на видеокарту передаются выбранный мип-уровень, мип-уровни для сторон (именно за счёт них происходит описанное выше схлопывание), размер и позиция вершины в параметрическом пространстве, а также номер квадродерева, используя примитив данных ``patch list''. В вершинном шейдере по номеру вершины выбираются её координаты как одного из углов единичного квадрата. Далее шейдер управления тесселляцией выставляет режим ``quad'' и уровни тесселляции в соотетствии с мип-уровнями текущего инстанса. После тесселляции оценочный шейдер получает на вход одну из протесселлированных вершин расположенных равномерно (не считая границ) по единичному квадрату и используя их координаты, номер квадродерева и позицию в параметрическом пространстве вычисляет позицию вершины в параметрическом пространстве и обращаясь к соответствующей странице кэша по алгоритму, описанному выше, находит необходимые вершинные атрибуты, выставляет позицию вершины и передаёт остальные атрибуты во фрагментный шейдер для расчёта освещения.

\section{Результаты}
Имплементация описанного выше решения была написана на C++20 с использованием библиотек Eigen, Function2, GLFW3, Cxxopts и Vulkan. Исходный код имеет размер порядка 10000 строк и доступен по ссылке \url{https://github.com/Mrkol/thesis_vgi}.

В качестве тестовых моделей были выбраны 3D-сканы Quixel Megascans \cite{quixel_megascans} в максимальном качестве. В следующей таблице приведено время работы этапов предобработки, а также количество полигонов и название использованных моделей. В столбец "подготовка" объединены этапы (1-2), в столбец "кластеризация" этапы (3-4), в "квадрангуляцию" -- (5-6), а последние 2 столбца соответствуют этапам (7) и (8). В разных строках указаны запуски с разной целевой ошибкой кластеризации, в столбце "кластеры" указано итоговое количество кластеров. Замеры происходили на Intel Core i5-470 (3.20Ghz) и видеокарте NVIDIA GeForce RTX 2070 SUPER.

\newcommand{\showpreviews}[1]{
  \begin{figure}
    \minipage{0.32\textwidth}
      \centering
      \includegraphics[scale=0.079]{high#1}
      \caption{Оригинальная модель. Вид с ракурса #1}
      \label{fig:preview#1start}
    \endminipage\hfill
    \minipage{0.32\textwidth}
      \centering
      \includegraphics[scale=0.079]{ours#1}
      \caption{Предлагаемый метод. Вид с ракурса #1}
    \endminipage\hfill
    \minipage{0.32\textwidth}
      \centering
      \includegraphics[scale=0.079]{lod#1}
      \caption{Уровни детализации. Вид с ракурса #1}
    \endminipage
    \\
    \minipage{0.32\textwidth}
      \centering
      \includegraphics[scale=0.079]{high#1_wireframe}
      \caption{Оригинальная модель. Вид с ракурса #1 (сетка)}
    \endminipage\hfill
    \minipage{0.32\textwidth}
      \centering
      \includegraphics[scale=0.079]{ours#1_wireframe}
      \caption{Предлагаемый метод. Вид с ракурса #1 (сетка)}
    \endminipage\hfill
    \minipage{0.32\textwidth}
      \centering
      \includegraphics[scale=0.079]{lod#1_wireframe}
      \caption{Уровни детализации. Вид с ракурса #1 (сетка)}
      \label{fig:preview#1end}
    \endminipage
  \end{figure}
}

\showpreviews{1}
\showpreviews{2}
\showpreviews{3}


\begin{table}[ht]
\small
\centering
\begin{tabular}{ l | p{16mm} | p{15mm} | p{17mm} | p{12mm} | p{14mm} | p{13mm} | p{17mm} }
                        & Полигоны (млн.) & Кластеры & Подготовка (мин.) & Кластер. (мин.) & Квадранг. (мин.) & Репарам. (мин.) & Ресемплинг (мин.) \\
\hline
\multirow{2}{18mm}{Rock Cliffs (uchwaffda)}
& 3    & 130 & 2.1   & 0.8  & 40   & 105    & 0.2   \\
& 3    & 164 & 2.1   & 0.8  & 40   & 83     & 0.2   \\
\hline
\multirow{3}{16mm}{Rock Sandstone (rlbx3)}
& 5    & 30  & 3.4   & 1.4  & 116  & 700    & 0.5   \\
& 5    & 224 & 3.5   & 1.4  & 34   & 200    & 0.3   \\
&&&&&&&\\
\end{tabular}
\caption{Производительность алгоритма предобработки}
\end{table}

Как видно из таблицы, время затраченное на репараметризацию сильно зависит от количества кластеров. Более того, при малом числе кластеров их форма как правило становится достаточно иррегулярной, что приводит к значительно большему времени на этапе квадрангуляции из-за необходимости делить рёбра. С другой стороны большее число кластеров приводит к более медленному рендерингу из-за необходимости адаптировать б\'ольшее число квадродеревьев.

\begin{figure}
  \minipage{0.45\textwidth}
    \begin{tikzpicture}
      \begin{axis}[
          ybar,
          symbolic x coords={Минимум,Среднее,Максимум},
          xtick=data,
          enlarge x limits=0.2,
          legend style={at={(0.025,0.975)}, anchor=north west},
          ylabel={FPS}
          ]
        \addplot[ybar,fill=yellow] coordinates {
          (Минимум,250) (Среднее,290) (Максимум,420)
        };
        \addplot[ybar,fill=red] coordinates {
          (Минимум,200) (Среднее,260) (Максимум,682)
        };
        \addplot[ybar,fill=blue] coordinates {
          (Минимум,24) (Среднее,26) (Максимум,457)
        };
        \legend{Уровни детализации,Предлагаемый метод,Исходная модель}
      \end{axis}
    \end{tikzpicture}
    \caption{Производительность рендеринга модели ``Rock Cliffs (uchwaffda)'' в кадрах в секунду (FPS, frames per second). Больше -- лучше}
    \label{fig:uchwaffda_perf}
  \endminipage\hfill
%
  \minipage{0.45\textwidth}
    \begin{tikzpicture}
      \begin{axis}[
          ybar,
          symbolic x coords={Минимум,Среднее,Максимум},
          xtick=data,
          enlarge x limits=0.2,
          legend style={at={(0.025,0.975)}, anchor=north west},
          ylabel={FPS}
          ]
        \addplot[ybar,fill=yellow] coordinates {
          (Минимум,130) (Среднее,140) (Максимум,250)
        };
        \addplot[ybar,fill=red] coordinates {
          (Минимум,103) (Среднее,140) (Максимум,309)
        };
        \addplot[ybar,fill=blue] coordinates {
          (Минимум,21) (Среднее,23) (Максимум,403)
        };
        \legend{Уровни детализации,Предлагаемый метод,Исходная модель}
      \end{axis}
    \end{tikzpicture}
    \caption{Производительность рендеринга модели ``Rock Assembly Rough (sjzbj)'' в кадрах в секунду (FPS, frames per second). Больше -- лучше}
    \label{fig:sjzbj_perf}
  \endminipage\hfill
\end{figure}

Производительность и качество рендерига же измерялись на процессоре Intel Core i7-8550U и его встроенной видеокарте. Производительность алгоритма при движении камеры показана на рисунках \ref{fig:uchwaffda_perf}-\ref{fig:sjzbj_perf}. Для сравнения были взяты исходная высокополигональная модель отрендеренная и предоставляемые Quixel её уровни детализации. Из графиков видно, что использование иерархического атласа не сильно ухудшает производительность по сравнению с наивным использованием уровней детализации, но при этом в разы быстрее рендеринга полной исходной модели.

\begin{figure}
  \centering
  \begin{tikzpicture}
    \begin{axis}[
        width=0.8\textwidth,
        height=0.6\textwidth,
        ybar,
        ymin=0,ymax=1,
        symbolic x coords={Разработанное решение,Уровни детализации},
        xtick=data,
        enlarge x limits=0.2,
        ylabel={SSIM},
        ]
      \addplot[ybar,fill=yellow] coordinates {
        (Разработанное решение,0.845) (Уровни детализации,0.627)
      };
      \addplot[ybar,fill=red] coordinates {
        (Разработанное решение,0.844) (Уровни детализации,0.740)
      };
      \addplot[ybar,fill=blue] coordinates {
        (Разработанное решение,0.834) (Уровни детализации, 0.640)
      };
    \end{axis}
  \end{tikzpicture}
  \caption{SSIM-качество отрендереных изображений с трёх ракурсов (обозначены цветами). Больше -- лучше}
  \label{fig:quality}
\end{figure}

Противопоставим эти показатели итоговому качеству картинки. Для его измерения была использована метрика SSIM \cite{wang2004image}, разработанная специально для сравнения видимого качества семантически одинаковых изображений. Сравниваемые изображения, а также изображения каркасов соответствующих моделей, представлены на рисунках \ref{fig:preview1start}-\ref{fig:preview3end}. Изображения полученные при помощи разработанного решения, а также полученные с помощью наивных уровней детализации, были сопоставлены с исходной высокополигональной моделью с трёх разных ракурсов. Результаты представлены на рисунке \ref{fig:quality}.

Таким образом разработанное решение позволяет добиться качества на 20 процентных пунктов лучше наивного подхода, при этом незначительно проигрывая ему в производительности.


\section{План дальнейших исследований}
В силу большой модульности и сложности метода предобработки, практически любая его часть может быть улучшена как по производительности, так и по качеству результата.

Для различных этапов предобработки планируется реализовать некоторое количество альтернативных подходов и сравнить получаемое качество, а также время предобработки. Из примечательных моментов -- поддержка разрывных вершинных атрибутов посредством проведения границ кластеров по границам разрывов, ускорение этапа репараметризации используя иные алгоритмы оптимизации, а также исследование модификаций предлагаемых в \cite{feng2010feature}. Этап распрямления границ кластеров же нуждается в полном перерассмотрении. В результате этой операции эвристика планарности кластеров сильно ухудшается, что в некоторых ситуациях приводит к недостаточной частоте семплирования выступов моделей. Более тонкий учёт геометрии поверхности на этапе сглаживания может помочь избавится от этой проблемы. Отметим, что аналогичный эффект проявляется и на этапе квадрангуляции, но в меньшей степени.

Ещё одним крупным направлением для дальнейших исследований являются алгоритмы адаптации при рендеринге иерархического атласа. Также планируется внедрение параллелизма в текущую имплементацию рендеринга (вынесение обновления кэша GPU в отдельный поток), и наконец рассмотрение возможности перенесения вычислений нагружающих центральный процессор в текущей имплементации (адаптация, вычисление мип уровней для границ) на графический процессор.


\newpage
\bibliography{bibliography}
\end{document}